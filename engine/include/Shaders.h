namespace shaders {
namespace simple {
const char vs_shader[] =
    "cbuffer PerModelConstants : register (b0)\n"
    "{\n"
    "	matrix MVP;\n"
    "}\n"
    "struct VertexShaderOutput\n"
    "{\n"
    "	float4 position : SV_POSITION;\n"
    "	float2 uv : TEXCOORD;\n"
    "};\n"
    "VertexShaderOutput VS_main(\n"
    "	float3 position : POSITION,\n"
    "	float2 uv : TEXCOORD)\n"
    "{\n"
    "	VertexShaderOutput output;\n"
    "   output.position = mul(MVP, float4(position, 1));\n"
    "	output.uv = uv;\n"
    "	return output;\n"
    "}\n";
const char fs_shader[] =
    "Texture2D<float4> inputTexture : register(t0);\n"
    "SamplerState     texureSampler : register(s0);\n"
    "float4 PS_main (float4 position : SV_POSITION,\n"
    "				float2 uv : TEXCOORD) : SV_TARGET\n"
    "{\n"
    "	return inputTexture.Sample (texureSampler, uv);\n"
    "}\n";
}  // namespace simple
namespace directionalLight {
const char vs_shader[] =
    "cbuffer PerModelConstants : register (b0)\n"
    "{\n"
    "	matrix MVP;\n"
    "	matrix Model;\n"
    "	float4 LightPos;\n"
    "	float4 LightDir;\n"
    "}\n"
    "struct VertexShaderOutput\n"
    "{\n"
    "	float4 position : SV_POSITION;\n"
    "	float2 uv : TEXCOORD0;\n"
    "	float3 normal : NORMAL;\n"
    "	float3 positionWorld : TEXCOORD1;\n"
    "};\n"
    "VertexShaderOutput VS_main(\n"
    "	float3 position : POSITION,\n"
    "	float2 uv : TEXCOORD,\n"
    "	float3 normal : NORMAL)\n"
    "{\n"
    "	VertexShaderOutput output;\n"
    "   float4 positionWorldSpace = mul(Model, float4(position, 1));"
    "   output.positionWorld = positionWorldSpace.xyz;"
    "   output.position = mul(MVP, float4(position, 1));\n"
    "	output.uv = uv;\n"
    "	output.normal = mul((float3x3)Model, normal);;\n"
    "	return output;\n"
    "}\n";
const char fs_shader[] =
    "cbuffer PerModelConstants : register (b0)\n"
    "{\n"
    "	matrix MVP;\n"
    "	matrix Model;\n"
    "	float4 LightPos;\n"
    "	float4 LightDir;\n"
    "}\n"
    "Texture2D<float4> inputTexture : register(t0);\n"
    "SamplerState     texureSampler : register(s0);\n"
    "float4 PS_main (float4 position : SV_POSITION,\n"
    "				float2 uv : TEXCOORD0, float3 normal : NORMAL, float3 positionWorld : TEXCOORD1) : SV_TARGET\n"
    "{\n" 
    "	float4 diffuseLighting = inputTexture.Sample (texureSampler, uv);\n" 
    "   float3 fragmentToLightDir = normalize(LightPos.xyz - positionWorld);"
    "   float cosAngle = saturate(dot(normalize(LightDir.xyz), normalize(positionWorld - LightPos.xyz)));"
    "   float lightFactor = 1.0;"
    "   if (cosAngle < 1 && cosAngle >= 0.96) lightFactor = 1.0; /* degree [0 : 15] */"
    "   else if (cosAngle < 0.96 && cosAngle >= 0.956) lightFactor = 1.033; /* degrees [15 : 17] */"
    "   else if (cosAngle < 0.956 && cosAngle >= 0.92) lightFactor = 0.9; /* degrees [17 : 23] */"
    "   else if (cosAngle < 0.92 && cosAngle >= 0.91) lightFactor = 0.5; /* degrees [23 : 24] */"
    "   else lightFactor = pow(0.5 * cosAngle / 0.91, 2); /* over 24 degrees */"
    "   float radius = 1000.0;"
    "   float attenuation  = 1.0 - pow(saturate(length(LightPos.xyz - positionWorld) / radius), 3);"
    "   attenuation  = lightFactor * attenuation;"
    "   float3 viewDir  = fragmentToLightDir;"
    "   float3 reflectDir = reflect(-fragmentToLightDir, normal);"
    "   float3 halfwayDir = normalize(fragmentToLightDir + viewDir);"
    "   float specLightingPhong = pow(saturate(dot(viewDir, reflectDir)), 1.7);"
    "   float specLightingBlinn = pow(saturate(dot(normal, halfwayDir)), 1.0);"
    "   float specLighting = 1.5 * specLightingPhong + 0.25 * specLightingBlinn;"
    "	float4 specular = float4(specLighting, specLighting, specLighting, 1.0);\n"
    "	return float4(attenuation, attenuation, attenuation, 1.0) * saturate(diffuseLighting * float4(0.6, 0.6, 0.6, 1.0)  + lightFactor * specular * 0.2);\n"
    "}\n";
}  // namespace directionalLight
}  // namespace shaders
